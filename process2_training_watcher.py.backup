#!/usr/bin/env python3

"""
Anti-Stockfish Process 3: Smart Training Watcher
1. Monitors Process 1 & 2 for new games
2. Extracts positions from games (Chess.com & Lichess formats)
3. Trains on extracted positions
"""

import subprocess
import time
import logging
from pathlib import Path
import json
import torch
import chess
import chess.pgn
import io

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [P2-TRAINER] - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('process2_training.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class SmartTrainingWatcher:
    """Watches for new games, extracts positions, trains"""
    
    def __init__(self):
        self.data_dir = Path("neural_network/data")
        self.model_dir = Path("neural_network/models")
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.model_dir.mkdir(parents=True, exist_ok=True)
        
        self.chesscom_dataset = self.data_dir / "chesscom_master_dataset.jsonl"
        self.positions_dataset = self.data_dir / "extracted_positions.jsonl"
        
        self.state_file = Path("process3_state.json")
        
        # Hardware
        self.GPU_AVAILABLE = torch.backends.mps.is_available()
        self.BATCH_SIZE = 256 if self.GPU_AVAILABLE else 64
        
        logger.info(f"ğŸ–¥ï¸  GPU: {'MPS (Metal)' if self.GPU_AVAILABLE else 'CPU'}, Batch: {self.BATCH_SIZE}")
        
        self.load_state()
    
    def load_state(self):
        """Load state"""
        if self.state_file.exists():
            with open(self.state_file) as f:
                self.state = json.load(f)
            logger.info(f"ğŸ“Š Loaded: {self.state['models_trained']} models trained, {self.state['total_positions_extracted']:,} positions extracted")
        else:
        self.state = {
            'last_chesscom_games': 0,
                'total_positions_extracted': 0,
                'models_trained': 0,
                'last_training_time': None
            }
            logger.info("ğŸ†• Starting fresh")
    
    def save_state(self):
        """Save state"""
        with open(self.state_file, 'w') as f:
            json.dump(self.state, f, indent=2)
    
    def get_dataset_size(self, filepath):
        """Get number of lines in dataset"""
        if not filepath.exists():
            return 0
        try:
            with open(filepath) as f:
                return sum(1 for _ in f)
        except:
            return 0
    
    def extract_positions_from_chesscom_game(self, game_data):
        """Extract positions from Chess.com game format"""
        positions = []
        
        try:
            # Chess.com format has 'pgn' field
            pgn_text = game_data.get('pgn')
            if not pgn_text:
                return positions
            
            # Parse PGN
            pgn = io.StringIO(pgn_text)
            game = chess.pgn.read_game(pgn)
            
            if not game:
                return positions
            
            # Get game outcome
            result = game.headers.get('Result', '*')
            if result == '1-0':
                outcome = 1.0  # White wins
            elif result == '0-1':
                outcome = 0.0  # Black wins
            else:
                outcome = 0.5  # Draw
            
            # Extract positions from moves
            board = game.board()
            move_number = 0
            
            for move in game.mainline_moves():
                # Get position before move
                fen = board.fen()
                
                # Create position data
                position = {
                    'fen': fen,
                    'move': move.uci(),
                    'outcome': outcome,
                    'move_number': move_number,
                    'source': 'chesscom'
                }
                
                positions.append(position)
                
                # Make the move
                board.push(move)
                move_number += 1
            
            return positions
        
        except Exception as e:
            logger.debug(f"Error extracting Chess.com positions: {e}")
            return positions
    
    def extract_positions_from_lichess_game(self, game_data):
        """Extract positions from Lichess game format"""
        positions = []
        
        try:
            # Lichess format has 'moves' field with UCI moves
            moves_str = game_data.get('moves', '')
            if not moves_str:
                return positions
            
            # Get game outcome
            winner = game_data.get('winner')
            if winner == 'white':
                outcome = 1.0
            elif winner == 'black':
                outcome = 0.0
            else:
                outcome = 0.5
            
            # Parse moves
            moves = moves_str.split()
            board = chess.Board()
            move_number = 0
            
            for move_uci in moves:
                try:
                    # Get position before move
                    fen = board.fen()
                    
                    # Create position data
                    position = {
                        'fen': fen,
                        'move': move_uci,
                        'outcome': outcome,
                        'move_number': move_number,
                        'source': 'lichess'
                    }
                    
                    positions.append(position)
                    
                    # Make the move
                    move = chess.Move.from_uci(move_uci)
                    board.push(move)
                    move_number += 1
                
                except:
                    break
            
            return positions
        
        except Exception as e:
            logger.debug(f"Error extracting Lichess positions: {e}")
            return positions
    
    def extract_positions_from_games(self):
        """Extract positions from all new games"""
        logger.info(f"\n{'='*80}")
        logger.info(f"ğŸ” EXTRACTING POSITIONS FROM GAMES")
        logger.info(f"{'='*80}\n")
        
        total_new_positions = 0
        
        # Process Chess.com games
        chesscom_games = self.get_dataset_size(self.chesscom_dataset)
        new_chesscom_games = chesscom_games - self.state['last_chesscom_games']
        
        if new_chesscom_games > 0:
            logger.info(f"ğŸ“Š Processing {new_chesscom_games} new Chess.com game entries...")
            
            with open(self.chesscom_dataset) as f:
                # Skip already processed entries
                for _ in range(self.state['last_chesscom_games']):
                    next(f)
                
                # Process new entries
                for line in f:
                    try:
                        entry = json.loads(line)
                        games = entry.get('games', [])
                        
                        # Extract positions from each game
                        for game_data in games:
                            positions = self.extract_positions_from_chesscom_game(game_data)
                            
                            # Save positions
                            with open(self.positions_dataset, 'a') as pf:
                                for pos in positions:
                                    pf.write(json.dumps(pos) + '\n')
                                    total_new_positions += 1
                    
                    except Exception as e:
                        logger.debug(f"Error processing Chess.com entry: {e}")
                        continue
            
            logger.info(f"  âœ… Chess.com: {total_new_positions:,} positions extracted")
            self.state['last_chesscom_games'] = chesscom_games
        
        self.state['total_positions_extracted'] += total_new_positions
        
        logger.info(f"\nğŸ“Š Total new positions: {total_new_positions:,}")
        logger.info(f"ğŸ“Š Total positions ever: {self.state['total_positions_extracted']:,}\n")
        
        return total_new_positions
    
    def check_for_new_games(self):
        """Check if new games have arrived"""
        chesscom_games = self.get_dataset_size(self.chesscom_dataset)
        
        chesscom_new = chesscom_games > self.state['last_chesscom_games']
        
        if chesscom_new:
            logger.info(f"ğŸ“¥ New games detected!")
            logger.info(f"   Chess.com: {self.state['last_chesscom_games']} â†’ {chesscom_games} entries")
            return True
        
        return False
    
    def train_model(self):
        """Train model with extracted positions"""
        logger.info(f"\n{'='*80}")
        logger.info(f"ğŸ§  TRAINING MODEL #{self.state['models_trained'] + 1}")
        logger.info(f"{'='*80}\n")
        
        total_positions = self.get_dataset_size(self.positions_dataset)
        
        if total_positions < 1000:
            logger.warning(f"âš ï¸  Not enough positions yet ({total_positions})")
            return False
        
        logger.info(f"ğŸ“Š Total positions: {total_positions:,}")
        logger.info(f"ğŸ”¥ GPU: {'MPS (Metal)' if self.GPU_AVAILABLE else 'CPU'}")
        logger.info(f"ğŸ“¦ Batch size: {self.BATCH_SIZE}\n")
        
        try:
            device = "mps" if self.GPU_AVAILABLE else "cpu"
            
            # Increase epochs as we get more data
            epochs = min(10 + (self.state['models_trained'] * 2), 30)
            
            cmd = [
                "python3", "neural_network/src/train.py",
                "--data", str(self.positions_dataset),
                "--epochs", str(epochs),
                "--batch-size", str(self.BATCH_SIZE),
                "--device", device,
                "--num-workers", "8"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)
            
            if result.returncode == 0:
                logger.info(f"âœ… Training complete!")
                self.state['models_trained'] += 1
                self.state['last_training_time'] = time.time()
                self.save_state()
                return True
            else:
                logger.error(f"âŒ Training failed: {result.stderr[:200]}")
                return False
        
        except Exception as e:
            logger.error(f"âŒ Training error: {e}")
            return False
    
    def run(self):
        """Main loop: Watch for games, extract positions, train"""
        logger.info(f"\n{'='*80}")
        logger.info(f"ğŸ‘ï¸  PROCESS 2: SMART TRAINING WATCHER")
        logger.info(f"{'='*80}\n")
        logger.info(f"ğŸ–¥ï¸  Hardware: Apple M4 Pro")
        logger.info(f"ğŸš€ GPU: {'Metal (MPS)' if self.GPU_AVAILABLE else 'CPU only'}")
        logger.info(f"ğŸ“Š Batch Size: {self.BATCH_SIZE}\n")
        logger.info(f"ğŸ“‹ Strategy:")
        logger.info(f"   1. Watch Process 1 for new games")
        logger.info(f"   2. Extract positions from Chess.com games")
        logger.info(f"   3. Train on extracted positions")
        logger.info(f"   4. Repeat forever\n")
        logger.info(f"ğŸ¯ Model gets smarter continuously!\n")
        
        CHECK_INTERVAL = 60  # Check every minute
        
        try:
            while True:
                logger.info(f"ğŸ‘ï¸  Checking for new games...")
                logger.info(f"ğŸ“Š Current status: {self.state['total_positions_extracted']:,} positions extracted, {self.state['models_trained']} models trained")
                
                if self.check_for_new_games():
                    logger.info(f"ğŸ‰ New games found! Extracting positions...")
                    
                    new_positions = self.extract_positions_from_games()
                    
                    if new_positions > 0:
                        self.save_state()
                        logger.info(f"\n{'='*80}")
                        logger.info(f"ğŸ‰ EXTRACTION COMPLETE")
                        logger.info(f"{'='*80}")
                        logger.info(f"ğŸ“Š New positions: {new_positions:,}")
                        logger.info(f"ğŸ“Š Total positions: {self.state['total_positions_extracted']:,}")
                        logger.info(f"ğŸ“Š Models trained: {self.state['models_trained']}")
                        logger.info(f"{'='*80}\n")
                        logger.info(f"ğŸ§  Starting training...")
                        self.train_model()
                    else:
                        logger.warning(f"âš ï¸  No positions extracted from new games")
                else:
                    logger.info(f"ğŸ’¤ No new games, waiting {CHECK_INTERVAL}s...\n")
                
                time.sleep(CHECK_INTERVAL)
        
        except KeyboardInterrupt:
            logger.info(f"\nâ¹ï¸  Stopped by user")
            logger.info(f"ğŸ“Š Models trained: {self.state['models_trained']}")
            logger.info(f"ğŸ“Š Positions extracted: {self.state['total_positions_extracted']:,}")
            self.save_state()

def main():
    watcher = SmartTrainingWatcher()
    watcher.run()

if __name__ == '__main__':
    main()
